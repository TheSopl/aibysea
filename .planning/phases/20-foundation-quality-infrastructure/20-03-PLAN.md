---
phase: 20-foundation-quality-infrastructure
plan: 03
type: execute
---

<objective>
Establish error monitoring and tracking infrastructure with Sentry.

Purpose: Gain visibility into production errors, enable proactive debugging, and establish observability foundation for enterprise operations. Currently flying blind - zero error tracking.
Output: Working Sentry integration with error boundaries and verified error tracking in dashboard.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-foundation-quality-infrastructure/20-RESEARCH.md
@.planning/phases/20-foundation-quality-infrastructure/CONTEXT.md
@.planning/phases/20-foundation-quality-infrastructure/20-01-SUMMARY.md
@.planning/phases/20-foundation-quality-infrastructure/20-02-SUMMARY.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md

**Current state:**
- Zero error monitoring infrastructure
- No error boundaries in app
- Production errors invisible until users report
- No observability for debugging issues

**Tech stack:**
- Next.js 16 App Router with React 19
- Vercel deployment (inferred)
- next-intl for i18n

**From RESEARCH.md:**
- Use Sentry (industry standard, best Next.js integration)
- Use `npx @sentry/wizard@latest -i nextjs` for automatic setup
- Separate client/server configs (sentry.client.config.ts, sentry.server.config.ts)
- Sample rate: 100% in dev, 10% in production (quota optimization)
- Upload source maps automatically (Sentry wizard configures)
- Don't hand-roll error logging - Sentry handles breadcrumbs, deduplication, alerting

**Critical pitfalls from RESEARCH.md:**
- Missing NEXT_PUBLIC_ prefix for client env vars (use NEXT_PUBLIC_SENTRY_DSN)
- Setting sample rates too high (100% in prod blows quota - use 10%)
- Forgetting source maps (stack traces useless without them)
- No error boundaries (unhandled errors crash app)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure Sentry SDK for Next.js</name>
  <files>sentry.client.config.ts, sentry.server.config.ts, next.config.ts, instrumentation.ts, .env.local, package.json</files>
  <action>
Run Sentry wizard for automatic setup:
```bash
npx @sentry/wizard@latest -i nextjs
```

This will:
- Install @sentry/nextjs package
- Create sentry.client.config.ts and sentry.server.config.ts
- Modify next.config.ts to add Sentry webpack plugin
- Create instrumentation.ts for runtime registration
- Prompt for Sentry DSN (get from Sentry account)

After wizard completes, modify configs:

In `sentry.client.config.ts`:
- Set `tracesSampleRate: process.env.NODE_ENV === "development" ? 1.0 : 0.1` (10% in prod)
- Enable session replay: `replaysSessionSampleRate: 0.1` (10% of sessions)
- Enable error replay: `replaysOnErrorSampleRate: 1.0` (100% when error occurs)
- Add `enableLogs: true`
- Add replay integration with maskAllText: true, blockAllMedia: true (privacy)
- Add ignoreErrors: ['ResizeObserver loop limit exceeded', 'Non-Error promise rejection captured']

In `sentry.server.config.ts`:
- Set same tracesSampleRate settings
- Enable logs

Update `.env.local` (create if doesn't exist):
```
# Sentry
NEXT_PUBLIC_SENTRY_DSN=https://...@sentry.io/...
SENTRY_AUTH_TOKEN=your-auth-token
```

Add to .gitignore:
```
# Sentry
.sentryclirc
```

AVOID: Using 100% sample rate in production (quota exceeded). AVOID: Forgetting NEXT_PUBLIC_ prefix for client DSN (won't work). AVOID: Not masking PII in session replay (privacy risk).
  </action>
  <verify>Run `npm run build` - should see Sentry webpack plugin upload source maps. Check build output for "Sentry: Source maps uploaded successfully".</verify>
  <done>Sentry installed, client and server configs created with proper sample rates, source maps configured, build succeeds with source map upload</done>
</task>

<task type="auto">
  <name>Task 2: Add error boundaries and test error tracking</name>
  <files>src/app/error.tsx, src/app/global-error.tsx, src/app/[locale]/(main)/error.tsx, src/lib/sentry-test.ts</files>
  <action>
Create `src/app/global-error.tsx` (must be 'use client'):
```tsx
"use client"
import * as Sentry from "@sentry/nextjs"
import NextError from "next/error"
import { useEffect } from "react"

export default function GlobalError({
  error
}: {
  error: Error & { digest?: string }
}) {
  useEffect(() => {
    Sentry.captureException(error)
  }, [error])

  return (
    <html>
      <body>
        <NextError statusCode={0} />
      </body>
    </html>
  )
}
```

Create `src/app/error.tsx` (route-level error boundary):
```tsx
"use client"
import * as Sentry from "@sentry/nextjs"
import { useEffect } from "react"

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    Sentry.captureException(error)
  }, [error])

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center">
        <h2 className="text-2xl font-bold">Something went wrong</h2>
        <button onClick={reset} className="mt-4 px-4 py-2 bg-blue-500 text-white rounded">
          Try again
        </button>
      </div>
    </div>
  )
}
```

Create `src/app/[locale]/(main)/error.tsx` (copy of error.tsx for main layout).

Create test error trigger in development:
Add a test page or API route that throws an error on purpose to verify Sentry capture.

AVOID: Not using 'use client' directive (error boundaries must be client components). AVOID: Forgetting useEffect dependency array (infinite loops). AVOID: Not calling Sentry.captureException (errors won't be tracked).
  </action>
  <verify>Trigger test error (visit test route or throw error in dev). Check Sentry dashboard (https://sentry.io) - should see error appear with full stack trace, breadcrumbs, and source-mapped file/line numbers.</verify>
  <done>Error boundaries created at root and route levels, test error captured in Sentry dashboard with source maps, stack traces show actual TypeScript file names (not bundle.js)</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Sentry error monitoring integrated with error boundaries and source maps</what-built>
  <how-to-verify>
1. Visit Sentry dashboard: https://sentry.io (log in with your account)
2. Navigate to the project created by Sentry wizard
3. Check Issues tab - should see the test error from Task 2
4. Click on the error to view details
5. Verify:
   - Stack trace shows actual TypeScript file names (e.g., `page.tsx:15`), not minified code
   - Breadcrumbs show user actions leading to error
   - Error is not marked as "unhandled" (error boundary caught it)
   - Source context shows code snippet around error line
6. Optional: Trigger another error to confirm real-time capture
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds with Sentry source map upload
- [ ] Error boundaries exist at root and route levels
- [ ] Test error appears in Sentry dashboard
- [ ] Stack traces show TypeScript file names (source maps working)
- [ ] No errors in browser console about Sentry initialization
</verification>

<success_criteria>

- All tasks completed
- Sentry SDK configured for client and server
- Source maps uploading automatically on build
- Error boundaries added to catch React errors
- Sample rates set appropriately (100% dev, 10% prod)
- Test error successfully tracked in Sentry dashboard
- Stack traces show source-mapped file names
  </success_criteria>

<output>
After completion, create `.planning/phases/20-foundation-quality-infrastructure/20-03-SUMMARY.md`:

# Phase 20 Plan 3: Error Monitoring with Sentry Summary

**Production error monitoring established with Sentry integration**

## Accomplishments

- Sentry SDK installed and configured for Next.js 16
- Client and server error tracking enabled
- Source maps uploading automatically on build
- Error boundaries added at root and route levels
- Sample rates optimized (10% in production, 100% in dev)
- Session replay enabled (10% of sessions, 100% on errors)
- Test error successfully tracked in Sentry dashboard
- Stack traces show source-mapped TypeScript file names

## Files Created/Modified

- `sentry.client.config.ts` - Client-side Sentry initialization
- `sentry.server.config.ts` - Server-side Sentry initialization
- `next.config.ts` - Modified with Sentry webpack plugin
- `instrumentation.ts` - Sentry runtime registration
- `src/app/global-error.tsx` - Global error boundary
- `src/app/error.tsx` - Root-level error boundary
- `src/app/[locale]/(main)/error.tsx` - Main layout error boundary
- `.env.local` - Added SENTRY_DSN and SENTRY_AUTH_TOKEN
- `package.json` - Added @sentry/nextjs dependency

## Decisions Made

- Used Sentry wizard for automatic setup (official recommended approach)
- Set 10% sample rate for production (quota optimization)
- Enabled session replay with PII masking (privacy-first)
- Added ignoreErrors for common false positives (ResizeObserver)
- Created error boundaries at multiple levels (graceful degradation)

## Issues Encountered

[Any issues and resolutions, or "None"]

## Next Step

Ready for 20-04-PLAN.md (CI/CD Pipeline + Database Migrations)
</output>
