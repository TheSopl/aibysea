---
phase: 07-ai-metrics-dashboard
plan: 02
type: auto
domain: real-time-state-management
---

<objective>
Wire real-time metrics to dashboard via Zustand store with Supabase Broadcast subscriptions and batching middleware.

Purpose: Enable the dashboard to receive and display live AI metrics without re-render storms—metrics flow from n8n webhooks → Supabase → Zustand (batched) → React components.
Output: Working real-time metrics stream with Zustand store, Supabase subscriptions, and batching middleware. Dashboard displays live values updating every 100-200ms.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
.planning/phases/07-ai-metrics-dashboard/07-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ai-metrics-dashboard/07-RESEARCH.md

**Key decisions from RESEARCH.md:**
- Use Zustand for metrics state (established from v1.0)
- Use Supabase Broadcast channel (not Postgres Changes) for high-frequency updates
- Batch updates every 100-200ms to prevent re-render storms
- Use windowing to keep only recent metrics in memory (prevent unbounded growth)

**Established patterns from v1.0:**
- Zustand already used in project for other state
- Supabase real-time subscriptions established (REPLICA IDENTITY FULL on messages table)
- Server wrapper + client component pattern for subscriptions

**Files to reference:**
- `src/stores/` - Existing Zustand store patterns
- `src/hooks/` - Existing custom hooks
- `src/lib/supabase.ts` - Supabase client configuration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand metrics store with batching middleware</name>
  <files>src/stores/metricsStore.ts</files>
  <action>Create Zustand store for real-time metrics. Store shape: { latency: number, tokenCount: number, confidence: number, contextSize: number, activeConversations: number, aiState: 'idle'|'thinking'|'responding', connectionStatus: 'connected'|'connecting'|'disconnected', updatedAt: Date, metrics: MetricsPoint[] }. Implement batching middleware that collects updates for 100ms then applies all at once to prevent re-render storms. Store should keep last 1000 metrics in memory (windowed) to prevent unbounded growth. Export useMetricsStore hook. See RESEARCH.md code examples for batching pattern.</action>
  <verify>Create test file src/stores/__tests__/metricsStore.test.ts that: (1) Creates store, (2) Calls updateMetrics 5 times in quick succession, (3) Verifies only 1 state change occurred (batching worked), (4) Wait 150ms, call again, verify state updated. npm test passes.</verify>
  <done>Store created with batching middleware, windowing at 1000 items, test passes, hook exports correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create useMetricsSubscription hook for Supabase Broadcast</name>
  <files>src/hooks/useMetricsSubscription.ts</files>
  <action>Create custom hook that subscribes to Supabase Broadcast channel "metrics" and updates Zustand store via batching. Hook should: (1) On component mount, subscribe to supabase.channel('metrics') with Broadcast event 'metrics_update', (2) On event, call store.updateMetrics(payload) which goes through batching middleware, (3) Handle connection status changes (connected/disconnected), (4) On unmount, unsubscribe and clean up. Use pattern from v1.0 server wrapper + client component (this is a client-side hook). Include error handling: if subscription fails, log error and update connectionStatus to 'disconnected'.</action>
  <verify>Hook imports correctly, no TypeScript errors, hook signature matches useMetricsSubscription(). Test: Create component that uses hook, verify subscription created on mount, verify cleanup on unmount.</verify>
  <done>Hook created, Supabase subscription working, connection status updates, error handling in place</done>
</task>

<task type="auto">
  <name>Task 3: Wire metrics store to dashboard component, add mock data stream for testing</name>
  <files>src/components/dashboard/AIMetricsDashboard.tsx (update), src/hooks/useMockMetricsStream.ts (test helper)</files>
  <action>Update AIMetricsDashboard to consume metrics from useMetricsStore hook instead of hardcoded placeholder values. Each metric card pulls value from store: latency → store.latency, confidence → store.confidence, etc. Add isDev/isTest mode: if process.env.NEXT_PUBLIC_MOCK_METRICS === 'true', use useMockMetricsStream hook that generates fake metrics every 200ms and updates store (for testing without n8n). In production, real metrics come from n8n via Supabase Broadcast. Update connection status badge to display store.connectionStatus.</action>
  <verify>npm run dev with NEXT_PUBLIC_MOCK_METRICS=true, visit dashboard, see metrics updating smoothly every 200ms. Check browser React DevTools: confirm dashboard re-renders at ~5Hz max (batching working). No jank or stuttering.</verify>
  <done>Dashboard pulls real data from store, mock mode works for testing, connection status displays correctly, no re-render storms visible</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test` passes for metricsStore tests
- [ ] `npm run dev` launches without errors
- [ ] Dashboard displays and updates live metrics (with NEXT_PUBLIC_MOCK_METRICS=true)
- [ ] Metrics update smoothly without jank (batching middleware working)
- [ ] Connection status badge updates correctly
- [ ] No TypeScript errors
- [ ] React DevTools shows efficient re-renders (<5Hz max)
- [ ] No console errors or warnings
</verification>

<success_criteria>

- Zustand store created with batching middleware and windowing
- Metrics hook connects to Supabase Broadcast "metrics" channel
- Connection status tracking working
- Dashboard displays live values from store
- Mock data stream for local testing (without n8n)
- Batching prevents re-render storms (verifiable in React DevTools)
- Error handling for subscription failures
- Code follows project TypeScript conventions

</success_criteria>

<output>
After completion, create `.planning/phases/07-ai-metrics-dashboard/07-02-SUMMARY.md`:

# Phase 7 Plan 02: Real-Time Metrics & State Management Summary

**Implemented real-time metrics streaming with Zustand store and Supabase Broadcast subscriptions.**

## Accomplishments

- Created Zustand metrics store with batching middleware (100ms windows)
- Implemented windowing to keep only last 1000 metrics in memory
- Built useMetricsSubscription hook for Supabase Broadcast channel
- Integrated metrics store with AIMetricsDashboard component
- Added mock metrics stream for local testing (NEXT_PUBLIC_MOCK_METRICS flag)
- Updated connection status badge to reflect subscription state

## Files Created/Modified

- `src/stores/metricsStore.ts` - Zustand store with batching + windowing
- `src/stores/__tests__/metricsStore.test.ts` - Store batching tests
- `src/hooks/useMetricsSubscription.ts` - Supabase Broadcast subscription hook
- `src/hooks/useMockMetricsStream.ts` - Mock data generator for testing
- `src/components/dashboard/AIMetricsDashboard.tsx` - Updated to consume store
- `src/components/dashboard/ConnectionStatus.tsx` - Now displays real subscription status

## Decisions Made

- Batching at 100ms (from RESEARCH.md) provides smooth feel (10 updates/sec max) without jitter
- Windowing at 1000 items chosen for ~100 seconds of 10Hz data (tunable per feedback)
- Mock stream uses NEXT_PUBLIC_MOCK_METRICS env var (easier than conditional imports)
- Supabase Broadcast chosen over Postgres Changes (scales better per RESEARCH.md)

## Issues Encountered

None

## Next Step

Ready for 07-03-PLAN.md: Chart visualization with Recharts and performance optimization

</output>
