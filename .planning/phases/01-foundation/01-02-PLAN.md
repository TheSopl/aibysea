---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Create database schema for the multi-channel inbox.

Purpose: Establish the data model that supports contacts, conversations, messages, and agents - the core entities of the inbox system.
Output: SQL schema applied to Supabase with RLS policies, TypeScript types generated for type-safe queries.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**Key decisions from PROJECT.md:**
- Phone number as primary contact identifier (WhatsApp always has phone)
- AI agent per channel that handles conversation until stuck or human requested
- Human takeover: agent clicks to take over, AI auto-pauses

**Data model requirements:**
- Contacts: phone number as primary identifier
- Conversations: link contact to channel, track AI vs human handling
- Messages: incoming/outgoing, timestamps, content
- Agents: internal users who can take over conversations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database schema SQL</name>
  <files>supabase/migrations/001_initial_schema.sql</files>
  <action>
    Create supabase/migrations/ directory and initial schema file.

    Schema design:

    ```sql
    -- Enable UUID extension
    create extension if not exists "uuid-ossp";

    -- Agents table (internal users)
    create table agents (
      id uuid primary key default uuid_generate_v4(),
      email text unique not null,
      name text not null,
      avatar_url text,
      created_at timestamptz default now(),
      updated_at timestamptz default now()
    );

    -- Contacts table (customers)
    create table contacts (
      id uuid primary key default uuid_generate_v4(),
      phone text unique not null,  -- Primary identifier for WhatsApp
      name text,
      metadata jsonb default '{}',  -- Flexible storage for channel-specific data
      created_at timestamptz default now(),
      updated_at timestamptz default now()
    );

    -- Conversations table
    create table conversations (
      id uuid primary key default uuid_generate_v4(),
      contact_id uuid references contacts(id) on delete cascade not null,
      channel text not null default 'whatsapp',  -- Future: 'telegram', 'sms', etc.
      status text not null default 'active',  -- 'active', 'closed'
      handler_type text not null default 'ai',  -- 'ai' or 'human'
      assigned_agent_id uuid references agents(id) on delete set null,
      last_message_at timestamptz,
      created_at timestamptz default now(),
      updated_at timestamptz default now()
    );

    -- Messages table
    create table messages (
      id uuid primary key default uuid_generate_v4(),
      conversation_id uuid references conversations(id) on delete cascade not null,
      direction text not null,  -- 'inbound' or 'outbound'
      content text not null,
      content_type text not null default 'text',  -- 'text', 'image', 'document', etc.
      metadata jsonb default '{}',  -- WhatsApp message ID, media URLs, etc.
      sender_type text not null,  -- 'contact', 'agent', 'ai'
      sender_id uuid,  -- agent.id if sender_type is 'agent'
      created_at timestamptz default now()
    );

    -- Indexes for common queries
    create index idx_conversations_contact on conversations(contact_id);
    create index idx_conversations_status on conversations(status);
    create index idx_conversations_handler on conversations(handler_type);
    create index idx_conversations_last_message on conversations(last_message_at desc);
    create index idx_messages_conversation on messages(conversation_id);
    create index idx_messages_created on messages(created_at desc);
    create index idx_contacts_phone on contacts(phone);

    -- Updated_at trigger function
    create or replace function update_updated_at()
    returns trigger as $$
    begin
      new.updated_at = now();
      return new;
    end;
    $$ language plpgsql;

    -- Apply updated_at triggers
    create trigger agents_updated_at before update on agents
      for each row execute function update_updated_at();
    create trigger contacts_updated_at before update on contacts
      for each row execute function update_updated_at();
    create trigger conversations_updated_at before update on conversations
      for each row execute function update_updated_at();

    -- RLS Policies (agents can see all data - internal tool)
    alter table agents enable row level security;
    alter table contacts enable row level security;
    alter table conversations enable row level security;
    alter table messages enable row level security;

    -- Agents can read/write all data (authenticated users are agents)
    create policy "Agents can view all agents" on agents
      for select to authenticated using (true);

    create policy "Agents can view all contacts" on contacts
      for select to authenticated using (true);
    create policy "Agents can insert contacts" on contacts
      for insert to authenticated with check (true);
    create policy "Agents can update contacts" on contacts
      for update to authenticated using (true);

    create policy "Agents can view all conversations" on conversations
      for select to authenticated using (true);
    create policy "Agents can insert conversations" on conversations
      for insert to authenticated with check (true);
    create policy "Agents can update conversations" on conversations
      for update to authenticated using (true);

    create policy "Agents can view all messages" on messages
      for select to authenticated using (true);
    create policy "Agents can insert messages" on messages
      for insert to authenticated with check (true);
    ```

    This schema supports:
    - Contact identification by phone (WhatsApp requirement)
    - Conversation ownership tracking (AI vs human)
    - Message history with direction and sender tracking
    - Flexible metadata fields for channel-specific data
    - RLS policies for authenticated agents (internal tool - all agents see all data)
  </action>
  <verify>SQL file exists at supabase/migrations/001_initial_schema.sql with all tables, indexes, and RLS policies</verify>
  <done>Schema SQL file created with agents, contacts, conversations, messages tables, indexes, triggers, and RLS policies</done>
</task>

<task type="auto">
  <name>Task 2: Generate TypeScript types from schema</name>
  <files>src/types/database.ts</files>
  <action>
    Since Supabase CLI requires a linked project to generate types, create manual type definitions that match the schema.

    Create src/types/database.ts:

    ```typescript
    export type Json =
      | string
      | number
      | boolean
      | null
      | { [key: string]: Json | undefined }
      | Json[]

    export interface Database {
      public: {
        Tables: {
          agents: {
            Row: {
              id: string
              email: string
              name: string
              avatar_url: string | null
              created_at: string
              updated_at: string
            }
            Insert: {
              id?: string
              email: string
              name: string
              avatar_url?: string | null
              created_at?: string
              updated_at?: string
            }
            Update: {
              id?: string
              email?: string
              name?: string
              avatar_url?: string | null
              created_at?: string
              updated_at?: string
            }
          }
          contacts: {
            Row: {
              id: string
              phone: string
              name: string | null
              metadata: Json
              created_at: string
              updated_at: string
            }
            Insert: {
              id?: string
              phone: string
              name?: string | null
              metadata?: Json
              created_at?: string
              updated_at?: string
            }
            Update: {
              id?: string
              phone?: string
              name?: string | null
              metadata?: Json
              created_at?: string
              updated_at?: string
            }
          }
          conversations: {
            Row: {
              id: string
              contact_id: string
              channel: string
              status: string
              handler_type: string
              assigned_agent_id: string | null
              last_message_at: string | null
              created_at: string
              updated_at: string
            }
            Insert: {
              id?: string
              contact_id: string
              channel?: string
              status?: string
              handler_type?: string
              assigned_agent_id?: string | null
              last_message_at?: string | null
              created_at?: string
              updated_at?: string
            }
            Update: {
              id?: string
              contact_id?: string
              channel?: string
              status?: string
              handler_type?: string
              assigned_agent_id?: string | null
              last_message_at?: string | null
              created_at?: string
              updated_at?: string
            }
          }
          messages: {
            Row: {
              id: string
              conversation_id: string
              direction: string
              content: string
              content_type: string
              metadata: Json
              sender_type: string
              sender_id: string | null
              created_at: string
            }
            Insert: {
              id?: string
              conversation_id: string
              direction: string
              content: string
              content_type?: string
              metadata?: Json
              sender_type: string
              sender_id?: string | null
              created_at?: string
            }
            Update: {
              id?: string
              conversation_id?: string
              direction?: string
              content?: string
              content_type?: string
              metadata?: Json
              sender_type?: string
              sender_id?: string | null
              created_at?: string
            }
          }
        }
      }
    }

    // Convenience type aliases
    export type Agent = Database['public']['Tables']['agents']['Row']
    export type Contact = Database['public']['Tables']['contacts']['Row']
    export type Conversation = Database['public']['Tables']['conversations']['Row']
    export type Message = Database['public']['Tables']['messages']['Row']

    export type NewAgent = Database['public']['Tables']['agents']['Insert']
    export type NewContact = Database['public']['Tables']['contacts']['Insert']
    export type NewConversation = Database['public']['Tables']['conversations']['Insert']
    export type NewMessage = Database['public']['Tables']['messages']['Insert']
    ```

    Update src/lib/supabase/client.ts to use typed client:
    ```typescript
    import { createBrowserClient } from '@supabase/ssr'
    import { Database } from '@/types/database'

    export function createClient() {
      return createBrowserClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      )
    }
    ```

    Update src/lib/supabase/server.ts similarly to use Database type.
  </action>
  <verify>npm run build succeeds, TypeScript recognizes Database types</verify>
  <done>TypeScript types created matching schema, Supabase clients typed with Database generic</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] supabase/migrations/001_initial_schema.sql exists with complete schema
- [ ] src/types/database.ts exists with all table types
- [ ] Supabase clients updated to use Database type
- [ ] `npm run build` succeeds
</verification>

<success_criteria>

- Database schema SQL ready to apply to Supabase
- TypeScript types match schema exactly
- Type-safe Supabase client configuration
- Build passes without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
