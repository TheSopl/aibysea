---
phase: 02.1-telegram-integration
plan: 01
type: execute
---

<objective>
Create Telegram bot integration with webhook receiving and message sending.

Purpose: Add Telegram as a messaging channel alongside WhatsApp, using the same database schema.
Output: Working Telegram webhook endpoint and message sending client.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/database.ts
@src/lib/whatsapp/signature.ts (pattern reference)
@src/services/whatsapp/processor.ts (pattern reference)

**Tech stack:** Next.js 16, Supabase, TypeScript
**Established patterns:**
- Message processor persisting to database
- Conversations track channel ('whatsapp', 'telegram')
- Admin client for RLS bypass in webhooks

**Telegram Bot API basics:**
- Base URL: https://api.telegram.org/bot{token}/
- Webhook: POST to your endpoint with Update object
- Send message: POST to /sendMessage with chat_id and text
- No signature verification needed (just use secret path)
- Updates contain message.chat.id (use as contact identifier)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Telegram library foundation</name>
  <files>src/lib/telegram/types.ts, src/lib/telegram/constants.ts, src/lib/telegram/index.ts</files>
  <action>
Create Telegram library structure mirroring WhatsApp pattern:

**src/lib/telegram/types.ts:**
```typescript
// Telegram Bot API types (subset we need)
export interface TelegramUpdate {
  update_id: number;
  message?: TelegramMessage;
}

export interface TelegramMessage {
  message_id: number;
  from?: TelegramUser;
  chat: TelegramChat;
  date: number; // Unix timestamp
  text?: string;
  // Add more as needed: photo, document, etc.
}

export interface TelegramUser {
  id: number;
  is_bot: boolean;
  first_name: string;
  last_name?: string;
  username?: string;
}

export interface TelegramChat {
  id: number;
  type: 'private' | 'group' | 'supergroup' | 'channel';
  first_name?: string;
  last_name?: string;
  username?: string;
}

export interface SendMessageResponse {
  ok: boolean;
  result?: TelegramMessage;
  description?: string;
  error_code?: number;
}
```

**src/lib/telegram/constants.ts:**
```typescript
export const TELEGRAM_API_VERSION = ''; // Telegram doesn't version like Meta

export function getTelegramApiUrl(): string {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  if (!token) throw new Error('TELEGRAM_BOT_TOKEN not configured');
  return `https://api.telegram.org/bot${token}`;
}

export function getWebhookSecretPath(): string {
  // Use a secret path segment to prevent random POST attacks
  return process.env.TELEGRAM_WEBHOOK_SECRET || 'telegram-webhook-secret';
}
```

**src/lib/telegram/index.ts:**
```typescript
export * from './types';
export * from './constants';
```
  </action>
  <verify>TypeScript compiles; types export correctly</verify>
  <done>Telegram library foundation with types and constants</done>
</task>

<task type="auto">
  <name>Task 2: Create Telegram webhook handler</name>
  <files>src/app/api/webhooks/telegram/[secret]/route.ts</files>
  <action>
Create webhook endpoint with secret path segment for security:

**src/app/api/webhooks/telegram/[secret]/route.ts:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import type { TelegramUpdate } from '@/lib/telegram/types';
import { getWebhookSecretPath } from '@/lib/telegram/constants';
import { processTelegramUpdate } from '@/services/telegram/processor';

/**
 * POST /api/webhooks/telegram/[secret]
 *
 * Receives Telegram bot updates. The [secret] path segment
 * acts as authentication (only Telegram knows the webhook URL).
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ secret: string }> }
): Promise<NextResponse> {
  const { secret } = await params;

  // Verify secret path matches
  if (secret !== getWebhookSecretPath()) {
    console.warn('[Telegram Webhook] Invalid secret path');
    return new NextResponse('Not Found', { status: 404 });
  }

  let update: TelegramUpdate;
  try {
    update = await request.json() as TelegramUpdate;
  } catch (error) {
    console.error('[Telegram Webhook] Failed to parse JSON:', error);
    return new NextResponse('Bad Request', { status: 400 });
  }

  console.log('[Telegram Webhook] Received update:', update.update_id);

  // Process asynchronously
  processTelegramUpdate(update).catch((error) => {
    console.error('[Telegram Webhook] Processing error:', error);
  });

  // Respond immediately
  return new NextResponse('OK', { status: 200 });
}
```
  </action>
  <verify>Route file created; TypeScript compiles</verify>
  <done>Telegram webhook endpoint with secret path authentication</done>
</task>

<task type="auto">
  <name>Task 3: Create Telegram message processor</name>
  <files>src/services/telegram/processor.ts</files>
  <action>
Create message processor following WhatsApp pattern:

**src/services/telegram/processor.ts:**
```typescript
import { createAdminClient } from '@/lib/supabase/admin';
import type { TelegramUpdate, TelegramMessage } from '@/lib/telegram/types';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type SupabaseAdmin = any;

export async function processTelegramUpdate(update: TelegramUpdate): Promise<void> {
  try {
    // Only process message updates for now
    if (!update.message) {
      console.log('[Telegram Processor] Skipping non-message update');
      return;
    }

    await processIncomingMessage(update.message);
  } catch (error) {
    console.error('[Telegram Processor] Error:', error);
  }
}

async function processIncomingMessage(message: TelegramMessage): Promise<void> {
  const supabase: SupabaseAdmin = createAdminClient();

  // Use chat.id as unique identifier (as string for consistency)
  const chatId = message.chat.id.toString();
  const messageId = message.message_id.toString();

  // Build contact name from Telegram user info
  const contactName = message.from
    ? [message.from.first_name, message.from.last_name].filter(Boolean).join(' ')
    : message.chat.first_name || null;

  console.log('[Telegram Processor] Processing message:', {
    chatId,
    messageId,
    from: contactName,
  });

  try {
    // Step 1: Find or create contact (using chat_id as phone equivalent)
    const contact = await findOrCreateContact(supabase, chatId, contactName);

    // Step 2: Find or create conversation
    const conversation = await findOrCreateConversation(supabase, contact.id);

    // Step 3: Check for duplicate
    const isDuplicate = await checkDuplicateMessage(supabase, `tg_${chatId}_${messageId}`);
    if (isDuplicate) {
      console.log('[Telegram Processor] Duplicate message, skipping');
      return;
    }

    // Step 4: Extract content
    const content = message.text || '[Non-text message]';

    // Step 5: Insert message
    const { error: insertError } = await supabase.from('messages').insert({
      conversation_id: conversation.id,
      direction: 'inbound',
      content,
      content_type: 'text',
      sender_type: 'customer',
      whatsapp_message_id: `tg_${chatId}_${messageId}`, // Reuse field for dedup
      metadata: {
        telegram_chat_id: chatId,
        telegram_message_id: messageId,
        telegram_user: message.from,
        timestamp: message.date,
      },
    });

    if (insertError) {
      console.error('[Telegram Processor] Insert error:', insertError);
      return;
    }

    console.log('[Telegram Processor] Message saved');

    // Step 6: Update conversation timestamps
    const now = new Date().toISOString();
    await supabase
      .from('conversations')
      .update({ last_message_at: now, last_customer_message_at: now })
      .eq('id', conversation.id);

    // Step 7: Update contact name if needed
    if (contactName && !contact.name) {
      await supabase
        .from('contacts')
        .update({ name: contactName })
        .eq('id', contact.id);
    }
  } catch (error) {
    console.error('[Telegram Processor] Error:', error);
  }
}

async function findOrCreateContact(
  supabase: SupabaseAdmin,
  chatId: string,
  name: string | null
): Promise<{ id: string; name: string | null }> {
  // Use telegram:{chat_id} as phone to distinguish from WhatsApp
  const phone = `telegram:${chatId}`;

  const { data: existing } = await supabase
    .from('contacts')
    .select('id, name')
    .eq('phone', phone)
    .single();

  if (existing) return existing;

  const { data: newContact, error } = await supabase
    .from('contacts')
    .insert({ phone, name, metadata: { telegram_chat_id: chatId } })
    .select('id, name')
    .single();

  if (error || !newContact) {
    throw new Error(`Failed to create contact: ${error?.message}`);
  }

  console.log('[Telegram Processor] Created contact:', phone);
  return newContact;
}

async function findOrCreateConversation(
  supabase: SupabaseAdmin,
  contactId: string
): Promise<{ id: string }> {
  const { data: existing } = await supabase
    .from('conversations')
    .select('id')
    .eq('contact_id', contactId)
    .eq('channel', 'telegram')
    .single();

  if (existing) return existing;

  const now = new Date().toISOString();
  const { data: newConv, error } = await supabase
    .from('conversations')
    .insert({
      contact_id: contactId,
      channel: 'telegram',
      status: 'active',
      handler_type: 'ai',
      last_message_at: now,
      last_customer_message_at: now,
    })
    .select('id')
    .single();

  if (error || !newConv) {
    throw new Error(`Failed to create conversation: ${error?.message}`);
  }

  console.log('[Telegram Processor] Created conversation');
  return newConv;
}

async function checkDuplicateMessage(
  supabase: SupabaseAdmin,
  messageKey: string
): Promise<boolean> {
  const { data } = await supabase
    .from('messages')
    .select('id')
    .eq('whatsapp_message_id', messageKey)
    .limit(1);

  return (data?.length ?? 0) > 0;
}
```
  </action>
  <verify>TypeScript compiles; processor exports processTelegramUpdate</verify>
  <done>Telegram message processor with database persistence</done>
</task>

<task type="auto">
  <name>Task 4: Create Telegram message sending client</name>
  <files>src/lib/telegram/client.ts</files>
  <action>
Create client for sending messages:

**src/lib/telegram/client.ts:**
```typescript
import { getTelegramApiUrl } from './constants';
import type { SendMessageResponse } from './types';

/**
 * Send a text message to a Telegram chat.
 */
export async function sendTelegramMessage(
  chatId: string | number,
  text: string
): Promise<SendMessageResponse> {
  const response = await fetch(`${getTelegramApiUrl()}/sendMessage`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: chatId,
      text,
      parse_mode: 'HTML', // Allows <b>, <i>, <a>, etc.
    }),
  });

  const data = await response.json() as SendMessageResponse;

  if (!data.ok) {
    console.error('[Telegram Client] Send failed:', data);
    throw new Error(`Telegram error ${data.error_code}: ${data.description}`);
  }

  return data;
}

/**
 * Set the webhook URL for the bot.
 * Call this once during setup.
 */
export async function setTelegramWebhook(webhookUrl: string): Promise<void> {
  const response = await fetch(`${getTelegramApiUrl()}/setWebhook`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      url: webhookUrl,
      allowed_updates: ['message'], // Only receive message updates
    }),
  });

  const data = await response.json();

  if (!data.ok) {
    throw new Error(`Failed to set webhook: ${data.description}`);
  }

  console.log('[Telegram Client] Webhook set successfully');
}

/**
 * Delete the webhook (useful for local testing with polling).
 */
export async function deleteTelegramWebhook(): Promise<void> {
  const response = await fetch(`${getTelegramApiUrl()}/deleteWebhook`, {
    method: 'POST',
  });

  const data = await response.json();

  if (!data.ok) {
    throw new Error(`Failed to delete webhook: ${data.description}`);
  }

  console.log('[Telegram Client] Webhook deleted');
}
```

**Update src/lib/telegram/index.ts to export client:**
```typescript
export * from './types';
export * from './constants';
export * from './client';
```
  </action>
  <verify>TypeScript compiles; sendTelegramMessage and setTelegramWebhook export</verify>
  <done>Telegram message sending client with webhook setup helpers</done>
</task>

<task type="auto">
  <name>Task 5: Update environment example and build</name>
  <files>.env.local.example</files>
  <action>
Add Telegram environment variables:

```
# Telegram Bot Configuration
TELEGRAM_BOT_TOKEN=           # From @BotFather
TELEGRAM_WEBHOOK_SECRET=      # Random string for webhook URL security
```

Run `npm run build` to verify everything compiles.
  </action>
  <verify>Environment variables documented; npm run build succeeds</verify>
  <done>Environment configured; build passes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Telegram types and constants created
- [ ] Webhook endpoint with secret path authentication
- [ ] Message processor persists to database
- [ ] Message sending client works
- [ ] Environment variables documented
- [ ] `npm run build` succeeds
</verification>

<success_criteria>
- All 5 tasks completed
- All verification checks pass
- Telegram integration ready for testing
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-telegram-integration/02.1-01-SUMMARY.md` following the summary template.
</output>
